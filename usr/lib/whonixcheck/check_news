#!/bin/bash

## This file is part of Whonix.
## Copyright (C) 2012 - 2014 Patrick Schleizer <adrelanos@riseup.net>
## See the file COPYING for copying conditions.

displaytime_helper() {
   if [ "$1" = "1" ]; then
      echo " "
   fi
}

displaytime() {
   ## Thanks to Stéphane Gimenez!
   ## http://unix.stackexchange.com/a/27014/49297
   ## Modified by Patrick Schleizer.
   local T D H M S X
   T="$1"
   D="$((T/60/60/24))"
   H="$((T/60/60%24))"
   M="$((T/60%60))"
   S="$((T%60))"
   X="0"
   [[ "$D" -gt "0" ]] && printf "$(displaytime_helper "$X")%d days" "$D" && X="1"
   [[ "$H" -gt "0" ]] && printf "$(displaytime_helper "$X")%d hours" "$H" && X="1"
   [[ "$M" -gt "0" ]] && printf "$(displaytime_helper "$X")%d minutes" "$M" && X="1"
   [[ "$S" -gt "0" ]] && printf "$(displaytime_helper "$X")%d seconds" "$S" && X="1"
   #[[ "$D" -gt "0" || "$H" -gt "0" || "$M" -gt "0" || "$S" -gt "0" ]] && printf 'and '
   true
}

download_whonix_news() {
   trap "error_handler" ERR

   whonixcheck_run_function whonix_news_preparation

   whonixcheck_run_function download_now_whonix_news

   if [ ! "$whonix_news_download_success" = "true" ]; then
      true "$BASH_SOURCE WARNING: whonix_news_download_success is not true, it is $whonix_news_verified_ok, return"
      return 0
   fi

   whonixcheck_run_function verify_whonix_news

   if [ ! "$whonix_news_verified_ok" = "true" ]; then
      true "$BASH_SOURCE WARNING: whonix_news_verified_ok is not true, it is $whonix_news_verified_ok, return"
      return 0
   fi

   whonixcheck_run_function extract_whonix_news

   if [ ! "$whonix_news_tar_exit_code" = "0" ]; then
      true "$BASH_SOURCE ERROR: whonix_news_tar_exit_code is not 0, it is $whonix_news_tar_exit_code, return"
      return 0
   fi

   whonixcheck_run_function check_whonix_debian_version
   whonixcheck_run_function check_whonix_build_version

   whonixcheck_run_function check_whonix_debian_news
   whonixcheck_run_function check_whonix_build_news

   whonixcheck_run_function check_whonix_show_news
}

whonix_news_preparation() {
   trap "error_handler" ERR

   if [ "$TEMP_DIR" = "" ]; then
      error "Variable TEMP_DIR is empty!"
      return 0
   fi

   whonix_news_hyperlink="<a href=https://www.whonix.org/wiki/Whonix_News>Whonix News</a>"

   whonix_news_download_dir="$TEMP_DIR/news/news_download_dir"
   whonix_news_verify_dir="$TEMP_DIR/news_verify_dir"

   SOCKS_PORT_WHONIX_NEWS="9114"

   local MSG="Whonix News Download: Checking for Whonix news and updates..."
   $output ${output_opts[@]} --messagecli --typecli "info" --message "$MSG"

   mkdir --parents "$whonix_news_download_dir"
   mkdir --parents "$whonix_news_verify_dir"

   declare -A -g whonix_news_web_link_list
   declare -A -g whonix_news_download_exit_code
   declare -A -g whonix_news_verify_check_gpg_exit_code

   ## whonix_news_web_link_list["web_link"]="file_name"
   whonix_news_web_link_list["http://sourceforge.net/projects/whonixdevelopermetafiles/files/internal/news_v4/whonix_news.tar.xz.asc/download"]="whonix_news.tar.xz.asc"
   whonix_news_web_link_list["http://sourceforge.net/projects/whonixdevelopermetafiles/files/internal/news_v4/whonix_news.tar.xz/download"]="whonix_news.tar.xz"
}

download_now_whonix_news() {
   trap "error_handler" ERR

   ## sf.net does not support ssl.
   ## --location is required since sf.net uses redirects to mirrors.

   local web_link

   for web_link in "${!whonix_news_web_link_list[@]}"; do
      ## Fallback.
      whonix_news_download_success="false"

      local file_name
      file_name="${whonix_news_web_link_list[$web_link]}"

      true "web_link: $web_link"
      true "file_name: $file_name"

      whonix_news_download_exit_code["$web_link"]="0"

      $CURL \
         $CURL_VERBOSE \
         --fail \
         --socks5-hostname "socks5h://$GATEWAY_IP:$SOCKS_PORT_WHONIX_NEWS/" \
         --location \
         --max-time 180 \
         --output "$whonix_news_download_dir/$file_name" \
         "$web_link" \
         &

      lastpid="$!"
      wait "$lastpid" || { whonix_news_download_exit_code["$web_link"]="$?" ; true; };

      if [ ! "${whonix_news_download_exit_code[$web_link]}" = "0" ]; then
         whonix_news_download_success="false"
         local curl_status_message
         curl_status_message="$(/usr/lib/curl-scripts/curl_exit_codes "${whonix_news_download_exit_code[$web_link]}")"
         local MSG="<p>$whonix_news_hyperlink Result: <b>Could not download Whonix News File</b> $file_name. (curl exit code: $curl_status_message)</p>"
         $output ${output_opts[@]} --messagex --typex "error" --message "$MSG"
         $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG"
         return 0
      fi

      whonix_news_download_success="true"
      if [ "$verbose" = "1" ]; then
         local MSG="<p>$whonix_news_hyperlink Result: Download of $file_name succeeded.</p>"
         $output ${output_opts[@]} --messagex --typex "error" --message "$MSG"
         $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG"
      fi

   done
}

verify_whonix_news() {
   trap "error_handler" ERR

   ## Sanity tests.
   command -v date >/dev/null
   command -v gpg >/dev/null

   ## Fallback
   whonix_news_verified_ok="false"

   local whonix_news_gpg_temp_dir
   whonix_news_gpg_temp_dir="$whonix_news_verify_dir/news_gpg"

   rm --recursive --force "$whonix_news_gpg_temp_dir"
   mkdir --parents "$whonix_news_gpg_temp_dir"
   chmod --recursive 700 "$whonix_news_gpg_temp_dir"

   whonix_news_verify_general_exit_code="0"

   true "a whonix_news_verify_general_exit_code: $whonix_news_verify_general_exit_code"

   gpg \
      --no-options \
      --homedir "$whonix_news_gpg_temp_dir" \
      --fingerprint \
      >/dev/null 2>/dev/null \
      || { whonix_news_verify_general_exit_code="$?" ; true; };

   true "b whonix_news_verify_general_exit_code: $whonix_news_verify_general_exit_code"

   local key

   shopt -s nullglob dotglob

   for key in "/usr/share/whonix/whonix-news-keys.d/"*; do
      local key_file_name
      key_file_name="$(basename "$key")"
      if [ "$key_file_name" = "placeholder" ]; then
         continue
      fi
      gpg \
         --no-options \
         --homedir "$whonix_news_gpg_temp_dir" \
         --import "$key" \
         2>/dev/null \
         || { whonix_news_verify_general_exit_code="$?" ; true; };
      if [ ! "$whonix_news_verify_general_exit_code" = "0" ]; then
         break
      fi
   done

   shopt -u nullglob dotglob

   true "c whonix_news_verify_general_exit_code: $whonix_news_verify_general_exit_code"

   if [ ! "$whonix_news_verify_general_exit_code" = "0" ]; then
      whonix_news_verified_ok="false"
      local MSG="<p>$whonix_news_hyperlink Download Result: <b>General Whonix News OpenPGP Verification Error.</b>
<br></br>Please report this bug!</p>"
      $output ${output_opts[@]} --messagex --typex "error" --message "$MSG"
      $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG"
      return 0
   fi

   whonix_news_verify_check_gpg_exit_code="0"

   true "d whonix_news_verify_check_gpg_exit_code: ${whonix_news_verify_check_gpg_exit_code}"

   local file_name signature timeout_after kill_after gpg_fd_one gpg_fd_one_file
   file_name="whonix_news.tar.xz"
   signature="whonix_news.tar.xz.asc"

   timeout_after="10"
   kill_after="10"

   ## Debugging.
   #timeout_after="0.001"
   #kill_after="0.001"

   gpg_fd_one_file="$whonix_news_verify_dir/news_gpg_fd_one"
   rm --force "$gpg_fd_one_file"

   timeout --kill-after="$kill_after" "$timeout_after" \
         gpg \
            --no-options \
            --status-file "$gpg_fd_one_file" \
            --homedir "$whonix_news_gpg_temp_dir" \
            --verify "$whonix_news_download_dir/$signature" \
            >/dev/null \
            2>/dev/null \
            &

   lastpid="$!"
   wait "$lastpid" || { whonix_news_verify_check_gpg_exit_code="$?" ; true; };

   ## `timeout` returns:
   ## - 124 if sigterm was sufficient
   ## - 137 if needed to use kill.

   if [ -f "$gpg_fd_one_file" ]; then
      gpg_fd_one="$(cat "$gpg_fd_one_file")"
   fi

   ## Example gpg_fd_one:
   ## [GNUPG:] SIG_ID ckz4Z2Th1KU9o1sVsWMY8JXdg+A 2013-10-13 1381635738
   ## [GNUPG:] GOODSIG 9C131AD3713AAEEF adrelanos <adrelanos@riseup.net>
   ## [GNUPG:] VALIDSIG 9B157153925C303A42253AFB9C131AD3713AAEEF 2013-10-13 1381635738 0 4 0 1 10 00 9B157153925C303A42253AFB9C131AD3713AAEEF
   ## [GNUPG:] TRUST_UNDEFINED

   ## Another example gpg_fd_one:
   ## [GNUPG:] ERRSIG 9C131AD3713AAEEF 1 10 00 1381635738 9
   ## [GNUPG:] NO_PUBKEY 9C131AD3713AAEEF

   true "e whonix_news_verify_check_gpg_exit_code: ${whonix_news_verify_check_gpg_exit_code}"

   ## Quote Werner Koch [1]:
   ## "there is no clear distinction between the codes and for proper error
   ## reporting you are advised to use the --status-fd messages."
   ## [1] http://lists.gnupg.org/pipermail/gnupg-devel/2005-December/022559.html
   #if [ ! "${whonix_news_verify_check_gpg_exit_code}" = "0" ]; then
      #true
   #fi

   local line validsig signed_on_unixtime
   ## Fallback.
   validsig="false"

   OIFS="$IFS"
   IFS="
"

   for line in $gpg_fd_one; do
      IFS="$OIFS"
      true "line: $line"
      local one two three four five
      read -r one two three four five _ <<< "$line"
      true "one: $one | two: $two | three: $three | four: $four | five: $five"
      if [ "$two" = "VALIDSIG" ]; then
         validsig="true"
         signed_on_unixtime="$five"
      fi
   done

   ## Fallback, in case $gpg_fd_one is empty.
   IFS="$OIFS"

   if [ ! "$validsig" = "true" ]; then
      whonix_news_verified_ok="false"
      local MSG="<p>$whonix_news_hyperlink Download Result:<br></br><b>Could not OpenPGP verify authenticity of Whonix News </b>$file_name!!!
<br></br>(gpg exit code: ${whonix_news_verify_check_gpg_exit_code} | validsig: $validsig)
<br></br>This is either,
<br></br>- a Whonix Bug,
<br></br>- an attack on Whonix,
<br></br>- or Whonix News Keys might be outdated. Upgrading using apt-get might fix this.</p>"
      $output ${output_opts[@]} --messagex --typex "error" --message "$MSG"
      $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG"
      return 0
   fi

   if [ "$signed_on_unixtime" = "" ]; then
      whonix_news_verified_ok="false"
      whonix_news_verify_check_gpg_exit_code="1000"
      local MSG="<p>$whonix_news_hyperlink Check: <br></br><b>variable signed_on_unixtime is empty.<br></br></b>
<br></br>Please report this bug!</p>"
      $output ${output_opts[@]} --messagex --typex "error" --message "$MSG"
      $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG"
      return 0
   fi

   ## Thanks to:
   ## http://mywiki.wooledge.org/BashFAQ/054
   if [[ "$signed_on_unixtime" != *[!0-9]* ]]; then
      true "'$signed_on_unixtime' is strictly numeric."
   else
      whonix_news_verified_ok="false"
      whonix_news_verify_check_gpg_exit_code="2000"
      local MSG="<p>$whonix_news_hyperlink Check: <br></br><b>Variable signed_on_unixtime includes a non-digit:</b> $signed_on_unixtime
<br></br>Please report this bug!</p>"
      $output ${output_opts[@]} --messagex --typex "error" --message "$MSG"
      $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG"
      return 0
   fi

   local current_unixtime current_time signed_on_unixtime_minus_current_unixtime signed_on_unixtime_minus_current_unixtime_output_pretty
   local month_has_seconds maximum_age_in_seconds current_unixtime_minus_signed_on_unixtime in_future_in_seconds in_future_pretty_output
   local maximum_age_in_seconds_pretty_output

   ## One month has 2592000 seconds.
   ## (60 [seconds] * 60 [minutes] * 24 [hours] * 30 [days])
   month_has_seconds="2592000"
   maximum_age_in_seconds="$month_has_seconds"
   maximum_age_in_seconds_pretty_output="$(displaytime "$maximum_age_in_seconds")"

   current_unixtime="$(date +%s)"
   current_time="$(date)"

   true "signed_on_unixtime: $signed_on_unixtime"
   true "current_unixtime: $current_unixtime"

   signed_on_unixtime_minus_current_unixtime="$(( $signed_on_unixtime - $current_unixtime ))"
   signed_on_unixtime_minus_current_unixtime_output_pretty="$(displaytime "$signed_on_unixtime_minus_current_unixtime")"

   current_unixtime_minus_signed_on_unixtime="$(( $current_unixtime - $signed_on_unixtime ))"
   current_unixtime_minus_signed_on_unixtime_output_pretty="$(displaytime "$current_unixtime_minus_signed_on_unixtime")"

   in_future_in_seconds="$(( $current_unixtime_minus_signed_on_unixtime - $maximum_age_in_seconds ))"
   in_future_pretty_output="$(displaytime "$in_future_in_seconds")"

   if [ "$current_unixtime" -le "$signed_on_unixtime" ]; then
      local lenient_up_to_minutes lenient_up_to_seconds
      lenient_up_to_minutes="30"
      lenient_up_to_seconds="$(( $lenient_up_to_minutes * 60 ))"
      if [ "$signed_on_unixtime_minus_current_unixtime" -lt "$lenient_up_to_seconds" ]; then
         local MSG="<p>$whonix_news_hyperlink Check: <br></br><b>Your clock might be slow.</b> According to your system clock,
Whonix News File was signed $signed_on_unixtime_minus_current_unixtime_output_pretty before current time.
Ignoring this, because it still is within range. (Whonix News File Signatures are valid up to $lenient_up_to_minutes minutes before.)</p>"
         if [ "$verbose" = "1" ]; then
            $output ${output_opts[@]} --messagex --typex "info" --message "$MSG"
            $output ${output_opts[@]} --messagecli --typecli "info" --message "$MSG"
         fi
      else
         whonix_news_verified_ok="false"
         whonix_news_verify_check_gpg_exit_code="3000"
         local MSG="<p>$whonix_news_hyperlink Check: <br></br><b>Your clock might be slow.</b> According to your system clock,
Whonix News File was signed $signed_on_unixtime_minus_current_unixtime_output_pretty before current time.
<br></br>Please run Timesync: <blockquote>Start menu -> Applications -> System -> Timesync</blockquote>
or in Terminal: <code><blockquote>timesync</blockquote></code></p>"
         $output ${output_opts[@]} --messagex --typex "error" --message "$MSG"
         $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG"
         return 0
      fi
   elif [ "$current_unixtime_minus_signed_on_unixtime" -ge "$maximum_age_in_seconds" ]; then
      whonix_news_verified_ok="false"
      whonix_news_verify_check_gpg_exit_code="4000"
      local MSG="<p>$whonix_news_hyperlink Check: <b>Whonix News File is no longer valid (outdated).</b>
<br></br>Either,
<br></br>- your clock might be fast (at least $in_future_pretty_output fast). In that case, please run Timesync: <blockquote>Start menu -> Applications -> System -> Timesync</blockquote>
                     or in Terminal: <code><blockquote>timesync</blockquote></code>
- it has been forgotten to refresh Whonix's News File by Whonix maintainers (invalid since $in_future_pretty_output)
<br></br>- this is a Whonix Bug
<br></br>- or this is an attack on Whonix</p>"
      $output ${output_opts[@]} --messagex --typex "error" --message "$MSG"
      $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG"
      return 0
   else
      local MSG="<p>$whonix_news_hyperlink Check: According to your system clock, Whonix News File was signed $current_unixtime_minus_signed_on_unixtime_output_pretty ago. \
(Whonix News File Signatures are valid up to $maximum_age_in_seconds_pretty_output.)</p>"
      if [ "$verbose" = "1" ]; then
         $output ${output_opts[@]} --messagex --typex "info" --message "$MSG"
         $output ${output_opts[@]} --messagecli --typecli "info" --message "$MSG"
      fi
   fi

   whonix_news_verified_ok="true"
   local MSG="<p>$whonix_news_hyperlink Check: news file valid.</p>"
   if [ "$verbose" = "1" ]; then
      $output ${output_opts[@]} --messagex --typex "info" --message "$MSG"
      $output ${output_opts[@]} --messagecli --typecli "info" --message "$MSG"
   fi
}

extract_whonix_news() {
   trap "error_handler" ERR

   local file_name timeout_after kill_after
   file_name="whonix_news.tar.xz"

   timeout_after="10"
   kill_after="10"

   ## Debugging.
   #timeout_after="0.001"
   #kill_after="0.001"

   whonix_news_tar_exit_code="0"

   timeout --kill-after="$kill_after" "$timeout_after" \
      tar \
         --extract \
         --verbose \
         --xz \
         --file="$whonix_news_download_dir/$file_name" \
         --directory="$whonix_news_download_dir/" \
         . \
         >/dev/null \
         &

   lastpid="$!"
   wait "$lastpid" || { whonix_news_tar_exit_code="$?" ; true; };

   ## `timeout` returns:
   ## - 124 if sigterm was sufficient
   ## - 137 if needed to use kill.

   if [ ! "$whonix_news_tar_exit_code" = "0" ]; then
      local MSG="<p>$whonix_news_hyperlink Download Result: <b>Could not extract $file_name!</b> (tar exit code: ${whonix_news_tar_exit_code})
<br></br>Please report this bug!</p>"
      $output ${output_opts[@]} --messagex --typex "error" --message "$MSG"
      $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG"
      return 0
   fi

   ## Debugging.
   #ls -la "$whonix_news_download_dir/"
}

check_whonix_debian_version() {
   trap "error_handler" ERR

   local file_name
   file_name="$whonix_news_download_dir/whonix_${vm_lower_case_short}_valid_deb_versions"

   if [ ! -f "$file_name" ]; then
      ## This file should always exist.
      whonix_news_result_output="<b>File $file_name does not exist.</b><br></br>Please report this bug!"
      return 0
   fi

   whonix_news_deb_up_to_date="false"

   local LINE
   while read -r LINE; do
      #true "$i: $LINE"
      if [ "$whonix_deb_package_version" = "$LINE" ]; then
         whonix_news_deb_up_to_date="true"
      fi
   done < "$file_name"

   if [ "$whonix_news_deb_up_to_date" = "true" ]; then
      ## Up to date...
      whonix_news_result_output="<span style=color:#008000>√</span> Up to date: <code>$whonix_deb_package_name</code> <u>$whonix_deb_package_version</u>"
   else
      ## Outdated...
      whonix_news_result_output="<b><span style=font-weight:600;color:#ff0000>✘</span> Outdated: Installed <code>$whonix_deb_package_name</code> <u>$whonix_deb_package_version</u> is outdated!</b>
<br></br>You should update. You can automatically update using Whonix's internal updater. Please update using:
<code><blockquote>sudo apt-get update && sudo apt-get dist-upgrade</blockquote></code>"
   fi
}

check_whonix_build_version() {
   trap "error_handler" ERR

   local file_name
   file_name="$whonix_news_download_dir/whonix_${vm_lower_case_short}_valid_build_versions"

   if [ ! -f "$file_name" ]; then
      ## This file should always exist.
      whonix_news_result_output="${whonix_news_result_output}<br></br>
<b>File $file_name does not exist.</b><br></br>Please report this bug!"
      return 0
   fi

   whonix_news_build_up_to_date="false"

   local LINE
   while read -r LINE; do
      #true "$i: $LINE"
      if [ "$whonix_build_version" = "$LINE" ]; then
         whonix_news_build_up_to_date="true"
      fi
   done < "$file_name"

   if [ "$whonix_news_build_up_to_date" = "true" ]; then
      ## Up to date...
      whonix_news_result_output="${whonix_news_result_output}<br></br>
<span style=color:#008000>√</span> Up to date: Whonix Build Version <u>$whonix_build_version</u>"
   else
      ## Outdated...
      whonix_news_result_output="${whonix_news_result_output}<br></br>
<span style=font-weight:600;color:#ff0000>✘</span> <b>Outdated: Whonix Build Version <u>$whonix_build_version</u> is outdated!</b>
<br></br>You should update. Sorry, automatically updating this Whonix version is not possible. You have to manually download a new Whonix image."
   fi
}

check_whonix_debian_news() {
   trap "error_handler" ERR

   local file_name
   file_name="$whonix_news_download_dir/whonix_${vm_lower_case_short}_${whonix_deb_package_version}_deb_news"

   if [ ! -f "$file_name" ]; then
      ## This will happen:
      ## - when using custom git tags / versions
      ## - when no news file has been uploaded yet
      if [ "$verbose" = "1" ]; then
         whonix_news_result_output="${whonix_news_result_output}<br></br>
There is no news file available for <code>$whonix_deb_package_name</code> version <u>${whonix_deb_package_version}</u> yet."
      fi
   else
      local message
      message="$(cat "$file_name")"
      message="$(/usr/lib/msgcollector/striphtml "$message")"
      if [ "$message" = "" ]; then
         return 0
      fi
      whonix_news_result_output="${whonix_news_result_output}<br></br>
$VM <code>$whonix_deb_package_name</code> <u>${whonix_deb_package_version}</u> News: <code><blockquote>$message</blockquote></code>"
   fi
}

check_whonix_build_news() {
   trap "error_handler" ERR

   local file_name
   file_name="$whonix_news_download_dir/whonix_${vm_lower_case_short}_${whonix_build_version}_build_news"

   if [ ! -f "$file_name" ]; then
      ## This will happen:
      ## - when using custom git tags / versions
      ## - when no news file has been uploaded yet
      if [ "$verbose" = "1" ]; then
         whonix_news_result_output="${whonix_news_result_output}<br></br>
There is no news file available for Whonix Build Version <u>${whonix_build_version}</u> yet."
      fi
   else
      local message
      message="$(cat "$file_name")"
      message="$(/usr/lib/msgcollector/striphtml "$message")"
      if [ "$message" = "" ]; then
         return 0
      fi
      whonix_news_result_output="${whonix_news_result_output}<br></br>
$VM Build <u>${whonix_build_version}</u> News: <code><blockquote>$message</blockquote></code>"
   fi
}

check_whonix_show_news() {
   trap "error_handler" ERR

   local type
   type="info"
   if [ ! "$whonix_news_build_up_to_date" = "true" ]; then
      type="warning"
   fi
   if [ ! "$whonix_news_deb_up_to_date" = "true" ]; then
      type="warning"
   fi

   local MSG="<p>$whonix_news_hyperlink Result:<br></br>
$whonix_news_result_output</p>"
   $output ${output_opts[@]} --messagex --typex "$type" --message "$MSG"
   $output ${output_opts[@]} --messagecli --typecli "$type" --message "$MSG"
}
